
---
title: Security
order: 800
layout: page
---

= Security in Vaadin Connect

== The Authentication flow

=== Vaadin Connect OAuth flow

In Vaadin Connect, the `_client_` that consumes services, is the front-end application running in the user's browser, whereas the java server acts as both: the `_resource server_` exposing services, and the `_authentication server_` verifying the user credentials.

The *_Vaadin Connect authentication flow_* is originated in the browser, when the javascript application accesses a service for the first time. The user's browser sends an authentication request with the password credentials, then the server validates those and emits an `_access token_` that the javascript application will use in sucesive service requests.

Besides the `_access token_`, the server returns a `_refresh token_` that will be used to get a new `_access token_` when the previous one expires, avoiding to send credentials again.

[NOTE]
====
It is application responsability to provide a proper form to introduce username and password.
====

image::vaadin-connect-oauth-flow.png[Vaadin Connect Authentication Diagram]
=== _Password Grant_ flow

Vaadin Connect flow meets the standars defined in the OAuth 2.0 https://tools.ietf.org/html/rfc6749#section-4.3[_Resource Owner Password Credentials Grant_] type, which is applicable for clients capable of obtaining the user's credentials directly.

The *_Password Grant flow_* is originated when the `_resource owner_` (aka user) introduces its username and password to the client application, then the client authenticates with the `_authorization server_` token endpoint requesting an `_access token_` by including the credentials received. Finally the `_authorization server_` validates the credentials, and issues an _access token_

image::password-grant-oauth-flow.png[Password Grant Diagram]


=== _Authorization Code Grant_ flow
===== (TODO: we can still remove this section)

Therefore, Vaadin Connect authentication is a simplified case of the entire OAuth 2.0 authentication process, that is described bellow for clarification.

The *_Authorization Code Grant flow_* describes how the user is redirected to the `_authorization server_` in order to, once authenticated, get an  `_authentication code_` that is passed back to the `_client server_` through the user's browser. The `_client server_` uses the `_authentication code_` besides the `_client secret_` to get an `_access token_` from the `_authorization server_` that will be used to consume the service from the `_resource server_`.

image::authorizarion-code-grant-oauth-flow.png[Authentication Code Grant Diagram]

== The Implementation

The Vaadin Connect runtime comes with a built-in auth server by default that makes easy to configure authentication for the provided services. It includes everything needed for the authentication providing easy mechanisms to validate credentials and tokens, and for the authorization of which roles can access certain services.

In addition the javascript API, includes everything to request an `_access token_` to the server endpoint using the user credentials, and to add it to each request made to service endpoints.

Since Vaadin Connect is implemented on top of Spring, the OAuth part relies on https://spring.io/projects/spring-security-oauth[Spring Security OAuth].

Vaadin Connect OAuth simplifies the process by providing the `@EnableVaadinConnectOAuthServer` which configures everything, except the users repository which must be provided by the developer via the `UserDetailsService` Bean.

[NOTE]
====
By default, Vaadin Connects uses BCrypted passwords, but you can override it by providint your own `PasswordEncoder` Bean.
====

== Server Configuration

=== Authentication

In order to enable built-int authentication, you need to mark your application with the `@EnableVaadinConnectOAuthServer` annotation, and provide a valid `UserDetailsService` and optionally a `PasswordEncoder`

==== Basic example

The following example defines just one user for the entire applicaton with a plain password.

[source,java]
----
@EnableVaadinConnectOAuthServer
public class MyDemoApplication {

  private UserDetails myUser = User.builder()
    .username("daffy").password("duck").roles("ROLE_USER").build();

  @Bean
  PasswordEncoder encoder encoder() {
    return NoOpPasswordEncoder.getInstance();
  }
  @Bean
  public UserDetailsService userDetailsService() {
      return username ->
          myUser.getUsername().equals(username) ? myUser : null;
  }
  ...
}
----

==== JPA User repository

The next example defines a user persistent database using JPA.

[source,java]
----
@EnableVaadinConnectOAuthServer
public class MyDemoApplication {
  @Bean
  public UserDetailsService userDetailsService(AccountRepository accountRepository) {
    return username -> accountRepository
        .findByUsername(username)
        .map(account -> User.builder()
            .username(account.getUsername())
            .password(account.getPassword())
            .roles("ROLE_USER").build())
        .orElseThrow(() -> new UsernameNotFoundException(username));
  }
  ...
}

/** The JPA Accounts Repository */
public interface AccountRepository extends JpaRepository<Account, Long> {
  Optional<Account> findByUsername(String username);
}

/** The JPA Account Entity */
@Entity
public class Account {
  @Id @GeneratedValue private Long id;
  @NotEmpty private String username;
  @JsonIgnor private String password;

  public Account() {
  }
  public Account(String username, String password) {
    this.username = username;
    this.password = password;
  }

  public Long getId() {
    return id;
  }
  public String getUsername() {
    return username;
  }
  public String getPassword() {
    return password;
  }
}
----

==== Custom AuthenticationManager

Finally you could configure your Vaadin Connect to use a custom authentication mechanism by providing an `AuthenticationManager` implementation.

In this example, any user password combination should work.

[source,java]
----
@EnableVaadinConnectOAuthServer
public class MyDemoApplication {

  @Bean
  AuthenticationManager authenticationManager(PasswordEncoder encoder) {
   return new AuthenticationManager() {
     @Override
     public Authentication authenticate(Authentication auth)
       throws AuthenticationException {
         return new UsernamePasswordAuthenticationToken(
           auth.getName(), encoder.encode(auth.getCredentials()), new ArrayList<>());
     }
   };
  }
  ...
}
----

=== Authorization

Vaadin Connect provides access control (aka ACL) to service classes via annotations:

- `@PermitAll`: grants access to any authenticated user
- `@RolesAllowed`: grants access to users having the specified roles
- `@DenyAll`: deny access to all users
- `@PermitAnonymous`: grants anonymous access

The anonymous annotation is processed separately from authenticated ones, meaning that, for instance, a service might be permitted to anonymous but denied to authenticated users.

_method-level_ annotations have preference over _class-level_ annotations

By default Vaadin connect deny anonymous accesses

==== Examples


[source,java]
----
@VaadinService
@DenyAll
public class MyService {

  public void deniedService() {
    // Dennied to all users
  }

  @PermitAll
  public void permittedToAllService() {
    // Permited to all authenticated users
  }

  @RolesAllowed("ROLE_ADMIN")
  public void permittedToToleService() {
    // Permited to all authenticated users belonging to the ROLE_ADMIN
  }

  @PermitAnonymous
  public void anonymousService() {
    // Permitted anonymous users but denied to authenticated users
  }
}
----

== Application Configuration

Vaadin Connect can be configured via the `application.properties` file.
For the OAuth feature, you only can customize the token endpoint which by default is set by default to `/oauth/token`

.application.properties
[source,java]
----
vaadin.connect.token.endpoint=/token
----
